- 方法重载是通过参数列表，报错参数的顺序。不能通过返回值区分，因为你在调用的时候，可能不需要处理返回值，所以java编译器肯定无法区分。

- 方法重载中，基本类型可以自动提升，已找到能匹配的方法。

- 一个方法是怎么知道自己被那个对象调用的呢?编译器做了一些幕后工作，他将对象的引用作为第一个参数传递给了方法，很想python的self参数。

- 在构造器中，可以用this调用其他构造器，注意两点：1，必须将构造器调用语句放在最前面，2，只能用this调用一个，不能再多了。  
另外，不可以在其他方法中调用构造器。

- finalize（）：在垃圾回收器准备回收时，会先调用finalize（），然后在下一次垃圾回收动作发生时，才真正回收内存。

- finalize（）不能用作通用的清理方法。因为：  
	1. 对象可能不被回收
	2. 垃圾回收不等于析构
	3. 垃圾回收只与内存有关  
那么finalize（）应用的场景是啥？既然java垃圾回收器可以管理所有new出来的对象，也就是说它管理不了不是通过new创建的对象，然而在java中一切皆是对象，所以这里说的不是通过new创建的对象，就是java通过调用本地方法创建的对象。java可以通过**本地方法调用**c/c++,然后c/c++可以调用任何语言。所以要在finilize（）中调用c/c++的free方法。

- 利用垃圾回收器准备回收时，会先调用finalize（），这个特性，可以在finalize方法中进行一些对象终止条件验证的工作，就是检查一些状态对不对。

- 使用System.gc()可以强制进行垃圾回收。

- jvm的垃圾回收是采用自适应的，jvm会监视内存块，如果比较稳定，采取标记-清扫，如果堆空间出现很多碎片，就会切换到停止-复制

- java保证类变量一定会在任何方法调用前得到初始化。  
先初始化静态类变量，在初始化非静态成员。  
静态初始化只在class对象加载的时候进行一次。

- 可变参数列表。可以传空。底层是将可变参列表当做数组来用的。

- enum类型，有values（）和ordinal（）方法
